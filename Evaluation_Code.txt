# -*- coding: utf-8 -*-
# ===== Sanity checks for diversity potential & benefit (print-only) =====
import pandas as pd
import numpy as np
from pathlib import Path

# ---- 读取结果：若内存中已有 res，就用它；否则从 CSV 读取 ----
try:
    _ = res  # noqa
    df = res.copy()
except NameError:
    model_name = "3_REWARD_180925"  # ← 若不同，请改成你的模型名
    path = Path(f"output/{model_name}_customer_level_diversity_eval.csv")
    df = pd.read_csv(path, parse_dates=["VERSION_DATE"]) if path.exists() else None
    if df is None:
        raise FileNotFoundError(f"Cannot find file: {path}")

# ---- 轻量清洗 ----
if "VERSION_DATE" in df.columns and not np.issubdtype(df["VERSION_DATE"].dtype, np.datetime64):
    # 若不是日期，就尽量解析
    try:
        df["VERSION_DATE"] = pd.to_datetime(df["VERSION_DATE"])
    except Exception:
        pass

for col in ["benefit", "readiness", "benefit_norm", "diversity_score"]:
    if col not in df.columns:
        raise KeyError(f"Missing column `{col}` in the evaluation dataframe.")

N = len(df)
div_mask = df["benefit"].fillna(0) > 0
n_div = int(div_mask.sum())
share_div = n_div / N if N > 0 else 0.0

def _summ(series):
    s = pd.Series(series).dropna()
    if s.empty:
        return {"count": 0}
    q = s.quantile([.1,.25,.5,.75,.9,.95,.99])
    return {
        "count": int(s.size),
        "mean": float(s.mean()),
        "std": float(s.std(ddof=0)) if s.size > 1 else 0.0,
        "min": float(s.min()),
        "p10": float(q.loc[.1]),
        "p25": float(q.loc[.25]),
        "p50": float(q.loc[.5]),
        "p75": float(q.loc[.75]),
        "p90": float(q.loc[.9]),
        "p95": float(q.loc[.95]),
        "p99": float(q.loc[.99]),
        "max": float(s.max()),
    }

print("\n================ OVERALL =================")
print(f"Rows: {N:,}")
print(f"Customers worth diversifying (benefit>0): {n_div:,}  ({share_div:,.2%})")

b_all   = _summ(df["benefit"])
b_pos   = _summ(df.loc[div_mask, "benefit"])
score_s = _summ(df["diversity_score"])
ready_s = _summ(df["readiness"])

def _pretty(d, title):
    if "count" not in d: 
        print(f"{title}: N/A"); 
        return
    print(f"\n{title}")
    keys = ["count","mean","std","min","p10","p25","p50","p75","p90","p95","p99","max"]
    for k in keys:
        if k in d:
            val = d[k]
            if isinstance(val, (int, np.integer)):
                print(f"  {k:>4}: {val:,}")
            else:
                print(f"  {k:>4}: {val:,.4f}")

_pretty(b_all,   "Benefit (all rows)")
_pretty(b_pos,   "Benefit (only benefit>0)")
_pretty(score_s, "Diversity score (0-1)")
_pretty(ready_s, "Readiness (0-1)")

# ---- 1) 每月对比：mean(benefit) / mean(diversity_score) / share(benefit>0) ----
if "VERSION_DATE" in df.columns:
    month = df["VERSION_DATE"]
    try:
        # 若为日期，按月 period；否则直接用原值
        month = df["VERSION_DATE"].dt.to_period("M").astype(str)
    except Exception:
        month = df["VERSION_DATE"].astype(str)

    monthly = (
        df.assign(month=month)
          .groupby("month")
          .agg(
              rows=("benefit","size"),
              mean_benefit=("benefit","mean"),
              median_benefit=("benefit","median"),
              mean_diversity_score=("diversity_score","mean"),
              mean_readiness=("readiness","mean"),
              share_diversified=("benefit", lambda s: (s>0).mean()),
          )
          .reset_index()
          .sort_values("month")
    )
    print("\n================ BY MONTH ================")
    print(monthly.to_string(index=False, float_format=lambda x: f"{x:,.4f}"))
else:
    print("\n[BY MONTH] `VERSION_DATE` not found; skipped.")

# ---- 2) 被“替换”为何产品最多（只看 benefit>0 的行） ----
print("\n============ PRODUCT REPLACEMENTS ==========")
prod_base_col = "baseline_prod" if "baseline_prod" in df.columns else \
                ("rec1_candidate_product" if "rec1_candidate_product" in df.columns else None)
prod_alt_col  = "best_div_prod" if "best_div_prod" in df.columns else None

if prod_base_col and prod_alt_col:
    rep = (
        df.loc[div_mask, [prod_base_col, prod_alt_col]]
          .groupby([prod_base_col, prod_alt_col])
          .size().reset_index(name="count")
          .sort_values("count", ascending=False)
    )
    print("\nTop replacement flows (baseline -> best_alt):")
    print(rep.head(15).to_string(index=False))

    # 各 baseline 的“被替换率”
    base_total = df.groupby(prod_base_col)["benefit"].size()
    base_repl  = df.loc[div_mask].groupby(prod_base_col)["benefit"].size()
    repl_rate  = (base_repl / base_total).fillna(0).reset_index(name="replacement_rate") \
                .sort_values("replacement_rate", ascending=False)
    print("\nReplacement rate by baseline product:")
    print(repl_rate.to_string(index=False, float_format=lambda x: f"{x:,.2%}"))
else:
    print("Product columns not found; skipped product-level analysis.")

# ---- 3) 分 segment（若有相关列） ----
print("\n================ BY SEGMENT ===============")
seg_candidates = ["CEM_SEGMENT","SEGMENT","segment","IND_DES2","SEG_DIV"]
seg_col = next((c for c in seg_candidates if c in df.columns), None)
if seg_col:
    seg_tbl = (
        df.groupby(seg_col)
          .agg(
              rows=("benefit","size"),
              share_diversified=("benefit", lambda s: (s>0).mean()),
              mean_benefit=("benefit","mean"),
              mean_diversity_score=("diversity_score","mean")
          ).reset_index()
          .sort_values("mean_diversity_score", ascending=False)
    )
    print(f"\nSegment summary by `{seg_col}` (top 15 by mean_diversity_score):")
    print(seg_tbl.head(15).to_string(index=False, float_format=lambda x: f"{x:,.4f}"))
else:
    print("No segment column found; skipped segment analysis.")

# ---- 4) 与 engagement 的关系（若有 rec1 的 engagement 概率） ----
print("\n============= ENGAGEMENT RELATION ==========")
eng_candidates = ["rec1_eng_proba","eng_p1","engagement_proba","top1_engagement_proba","p1_eng"]
eng_col = next((c for c in eng_candidates if c in df.columns), None)

if eng_col:
    # 分位分箱（避免重复边界导致报错）
    try:
        bins = pd.qcut(df[eng_col], q=10, duplicates="drop")
    except Exception:
        # 若值过少/常量，用等宽分箱
        bins = pd.cut(df[eng_col], bins=10, include_lowest=True)
    rel = (
        df.assign(eng_bin=bins)
          .groupby("eng_bin")
          .agg(
              rows=("benefit","size"),
              mean_eng=(eng_col,"mean"),
              share_diversified=("benefit", lambda s: (s>0).mean()),
              mean_benefit=("benefit","mean"),
              mean_diversity_score=("diversity_score","mean"),
          )
          .reset_index()
          .sort_values("mean_eng")
    )
    print(f"\nRelationship vs engagement `{eng_col}` (binned):")
    print(rel.to_string(index=False, float_format=lambda x: f"{x:,.4f}"))
else:
    print("No engagement-probability column found; skipped engagement relationship.")