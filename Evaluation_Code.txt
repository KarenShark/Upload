下面给你三块可直接粘到 notebook 的代码（全部自带健壮性检查与英文打印）。我统一假设你已经把上一节保存好的评估表读成了 eval_df（或你也可以用第一段里给的 read_csv 直接载入）。

⸻

1) 设运营阈值，计算 share_diversified（并做阈值灵敏度）

# === Load (若你已有 eval_df 可跳过这三行) ===
import pandas as pd, numpy as np
from pathlib import Path

model_name = "3_REWARD_180925"
eval_path  = Path(f"output/{model_name}_customer_level_diversity_eval.csv")
eval_df    = pd.read_csv(eval_path, parse_dates=['VERSION_DATE'])

# 基本检查
need_cols = ['VERSION_DATE','CUST_SERIAL_NO','readiness','benefit','diversity_score',
             'baseline_prod','best_div_prod']
missing = [c for c in need_cols if c not in eval_df.columns]
assert not missing, f"Missing columns in eval_df: {missing}"

# 统一月份列
eval_df['month'] = eval_df['VERSION_DATE'].dt.to_period('M').astype(str)

def threshold_sweep(df, readiness_thr=0.8, quantiles=(0.50, 0.75, 0.90), label_prefix="Q"):
    """按若干 benefit 分位数阈值 + readiness 阈值，统计 share、uplift 等"""
    pos = df['benefit'] > 0
    qmap = df.loc[pos, 'benefit'].quantile(list(quantiles)).to_dict() if pos.any() else {}
    rows = []

    # 也加一个绝对阈值 0（只要收益>0 且 readiness 达标就多元化）
    qmap = {**{f"{label_prefix}{int(q*100)}": thr for q, thr in qmap.items()},
            "ABS>0": 0.0}

    for name, thr in qmap.items():
        mask = (df['readiness'] >= readiness_thr) & (df['benefit'] >= thr)
        share = mask.mean()
        cnt   = int(mask.sum())
        rows_total = len(df)
        mean_benefit_div = df.loc[mask, 'benefit'].mean() if cnt>0 else 0.0
        total_uplift     = df.loc[mask, 'benefit'].sum()
        mean_divscore    = df.loc[mask, 'diversity_score'].mean() if cnt>0 else 0.0

        # 分月
        by_m = (df.assign(_flag=mask)
                  .groupby('month')
                  .agg(rows=('CUST_SERIAL_NO','size'),
                       share_diversified=('_flag','mean'),
                       mean_benefit=('benefit', lambda x: x[mask.loc[x.index]].mean() if x.index.size else np.nan))
                  .reset_index())

        print(f"\n=== Threshold: readiness≥{readiness_thr}, benefit≥{name} (={thr:.2f}) ===")
        print(f"rows: {rows_total:,} | diversified_cnt: {cnt:,} | share_diversified: {share:.3f}")
        print(f"mean_benefit_if_diversified: {mean_benefit_div:.2f} | total_uplift: {total_uplift:,.2f} | mean_diversity_score: {mean_divscore:.3f}")
        print("\nBy month:")
        print(by_m.to_string(index=False))

        rows.append({
            'benefit_thr_name': name,
            'benefit_thr': thr,
            'readiness_thr': readiness_thr,
            'rows': rows_total,
            'div_cnt': cnt,
            'share_diversified': share,
            'mean_benefit_div': mean_benefit_div,
            'total_uplift': total_uplift,
            'mean_diversity_score': mean_divscore
        })

    return pd.DataFrame(rows).sort_values('benefit_thr')

# 跑一版：readiness≥0.8，benefit 取 {p50, p75, p90, >0}
summary_tbl = threshold_sweep(eval_df, readiness_thr=0.8, quantiles=(0.5, 0.75, 0.9))
print("\n=== Threshold sensitivity summary ===")
print(summary_tbl.to_string(index=False))

解释：
	•	你会同时得到总体 share / uplift 以及分月对比，便于运营定阈值（例如选 readiness≥0.8 & benefit≥Q75）。
	•	最下方 summary_tbl 汇总了各阈值组合下的覆盖率与收益，可直接导出作决策表。

⸻

2) 画“产品替换矩阵”热力图（baseline → best_alt）

import matplotlib.pyplot as plt
import numpy as np

# 选择一个阈值组合来“定义多元化”
READINESS_THR = 0.8
# 选用上一步算出来的 p75；如未跑上一步，可换成常数例如 500
benefit_thr = summary_tbl.loc[summary_tbl['benefit_thr_name']=="Q75",'benefit_thr'].max() \
              if 'summary_tbl' in globals() else 500.0

div_mask = (eval_df['readiness'] >= READINESS_THR) & (eval_df['benefit'] >= benefit_thr)

# 生成替换计数表
flows = (eval_df.loc[div_mask, ['baseline_prod','best_div_prod']]
                  .groupby(['baseline_prod','best_div_prod'])
                  .size()
                  .unstack(fill_value=0))

# 行列按总量排序
flows = flows.loc[flows.sum(1).sort_values(ascending=False).index,
                  flows.sum(0).sort_values(ascending=False).index]

print("\nTop replacement flows (table):")
print(flows.head(20).to_string())

# 画热力图（matplotlib）
fig, ax = plt.subplots(figsize=(8,6))
im = ax.imshow(flows.values, aspect='auto')
ax.set_xticks(np.arange(flows.shape[1])); ax.set_xticklabels(flows.columns, rotation=45, ha='right')
ax.set_yticks(np.arange(flows.shape[0])); ax.set_yticklabels(flows.index)
ax.set_title(f"Replacement heatmap (readiness≥{READINESS_THR}, benefit≥{benefit_thr:.0f})")
fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04, label="count")

# 数字标注（可选）
for i in range(flows.shape[0]):
    for j in range(flows.shape[1]):
        v = flows.values[i, j]
        if v>0:
            ax.text(j, i, str(v), ha='center', va='center', fontsize=8)

plt.tight_layout()
plt.show()

解释：
	•	这张热图非常适合跟业务讨论哪些 baseline 最常被替换成什么；行列已按总量排序，热点一眼能看出。

⸻

3) 加入 segment 与 engagement_proba，再跑分群/相关性

import re

# === 3.1 追加 segment（如文件存在） ===
try:
    seg_map = pd.read_csv('output/customer_segment_map.csv')  # 需包含: CUST_SERIAL_NO, segment
    assert {'CUST_SERIAL_NO','segment'}.issubset(seg_map.columns)
    seg_map['CUST_SERIAL_NO'] = seg_map['CUST_SERIAL_NO'].astype(eval_df['CUST_SERIAL_NO'].dtype)
    eval_df = eval_df.merge(seg_map[['CUST_SERIAL_NO','segment']], on='CUST_SERIAL_NO', how='left')
    print("Segment column merged.")
except Exception as e:
    print(f"Segment map not found or invalid, skip segment analysis. Detail: {e}")

# === 3.2 识别 engagement 概率列 ===
def find_eng_col(df):
    cand = [c for c in df.columns
            if re.search(r'(rec1|top1).*eng(agement)?(_)?proba', c, flags=re.I) or c.lower()=='eng_p1']
    return cand[0] if cand else None

eng_col = find_eng_col(eval_df)
if eng_col is None:
    # 兜底：若没有概率列，用 rec1_score 作为参与度 proxy
    eng_col = 'rec1_score' if 'rec1_score' in eval_df.columns else None

if eng_col:
    print(f"Using engagement column: {eng_col}")
else:
    print("No engagement column found; engagement relationship will be skipped.")

# === 3.3 在选定运营阈值下，做分群/相关性 ===
READINESS_THR = 0.8
benefit_thr   = summary_tbl.loc[summary_tbl['benefit_thr_name']=="Q75",'benefit_thr'].max() \
                if 'summary_tbl' in globals() else 500.0
mask = (eval_df['readiness'] >= READINESS_THR) & (eval_df['benefit'] >= benefit_thr)
eval_df = eval_df.assign(_diversified=mask)

# --- 分 segment（若有） ---
if 'segment' in eval_df.columns:
    seg_view = (eval_df
                .groupby('segment')
                .agg(rows=('CUST_SERIAL_NO','size'),
                     share_diversified=('_diversified','mean'),
                     mean_benefit=('benefit','mean'),
                     mean_diversity_score=('diversity_score','mean'))
                .sort_values('share_diversified', ascending=False)
                .reset_index())
    print("\n=== Diversification by segment ===")
    print(seg_view.to_string(index=False))
else:
    print("\nNo segment column; skipped segment breakdown.")

# --- 与 engagement 的关系（若有） ---
if eng_col:
    # 分箱：10 等分
    eval_df['_eng_bin'] = pd.qcut(eval_df[eng_col].rank(method='first'), q=10, labels=False)
    eng_view = (eval_df
                .groupby('_eng_bin')
                .agg(rows=('CUST_SERIAL_NO','size'),
                     mean_eng=(eng_col,'mean'),
                     share_diversified=('_diversified','mean'),
                     mean_benefit=('benefit','mean'),
                     mean_readiness=('readiness','mean'))
                .reset_index()
                .sort_values('_eng_bin'))
    print("\n=== Diversification vs. engagement deciles ===")
    print(eng_view.to_string(index=False))
else:
    print("\nNo engagement-probability proxy found; skipped engagement relationship.")

解释：
	•	segment：输出每个客群的覆盖率/收益/多元化分值，帮助定位“多元化最有效”的客群。
	•	engagement：按 10 分位画出参与度越高是否越适合多元化的证据（覆盖率/收益随分位上升应该更优）。

⸻

小结你要怎么用
	•	先跑 Section 1 拿到 summary_tbl，和业务一起选一个运营阈值（推荐 readiness≥0.8 & benefit≥Q75 作为起点）。
	•	用 Section 2 的热图对齐“哪些替换路径合理/需要加规则”。
	•	用 Section 3 的分 segment 与 engagement 结果，确认在哪些客群先落地，并验证“高参与度→更适合多元化”的假设。

需要把这些输出落盘（CSV/PNG）用于汇报，我也可以给你一键保存版本。